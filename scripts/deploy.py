#!/usr/bin/env python3
"""
Utility script to bootstrap the Care Monitoring System on a fresh workstation.

Features:
  • Checks core prerequisites (Node.js, npm, Docker, docker-compose)
  • Generates sensible .env files for the root project, API Gateway, and microservices
  • Installs npm dependencies via workspaces
  • Starts the local infrastructure stack (Postgres, Redis, RabbitMQ)
  • Applies database migrations
  • Optionally launches all services in development mode
"""

from __future__ import annotations

import argparse
import os
import platform
import re
import shutil
import subprocess
import sys
from pathlib import Path
from textwrap import dedent


PROJECT_ROOT = Path(__file__).resolve().parents[1]


SERVICE_PORTS = {
    "auth-service": 3001,
    "user-service": 3002,
    "device-service": 3003,
    "telemetry-service": 3004,
    "alert-service": 3005,
    "location-service": 3006,
    "billing-service": 3007,
    "integration-service": 3008,
    "dispatcher-service": 3009,
    "analytics-service": 3010,
    "ai-prediction-service": 3011,
}


SERVICE_DATABASES = {
    "auth-service": "auth_db",
    "user-service": "user_db",
    "device-service": "device_db",
    "telemetry-service": "telemetry_db",
    "alert-service": "alert_db",
    "location-service": "location_db",
    "billing-service": "billing_db",
    "integration-service": "integration_db",
    "dispatcher-service": "dispatcher_db",
    "analytics-service": "analytics_db",
    "ai-prediction-service": "ai_prediction_db",
}


REQUIREMENTS = [
    {"name": "Node.js", "cmd": ["node", "--version"], "min_version": "18.0.0"},
    {"name": "npm", "cmd": ["npm", "--version"], "min_version": "9.0.0"},
    {"name": "Docker", "cmd": ["docker", "--version"], "min_version": "20.10.0"},
    {"name": "docker-compose", "cmd": ["docker-compose", "--version"], "min_version": "2.0.0"},
]


def log(message: str, level: str = "INFO") -> None:
    print(f"[{level}] {message}")


def run_command(command: list[str], cwd: Path | None = None) -> None:
    display = " ".join(command)
    log(f"Executing: {display}")
    result = subprocess.run(command, cwd=cwd or PROJECT_ROOT)
    if result.returncode != 0:
        raise RuntimeError(f"Command failed ({display}) with code {result.returncode}")


def capture_command(command: list[str]) -> str:
    try:
        result = subprocess.run(
            command,
            cwd=PROJECT_ROOT,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            check=False,
        )
    except FileNotFoundError as exc:
        raise RuntimeError(f"Command not found: {' '.join(command)}") from exc

    output = result.stdout.strip()
    if result.returncode != 0:
        raise RuntimeError(f"Command {' '.join(command)} failed: {output}")
    return output


def extract_version(output: str) -> str:
    match = re.search(r"(\d+\.\d+\.\d+)", output)
    if match:
        return match.group(1)
    match = re.search(r"(\d+\.\d+)", output)
    if match:
        return f"{match.group(1)}.0"
    raise RuntimeError(f"Unable to parse version from output: {output}")


def normalize_version(version: str) -> tuple[int, int, int]:
    parts = version.strip().lstrip("v").split(".")
    nums = [int(p) for p in parts]
    while len(nums) < 3:
        nums.append(0)
    return tuple(nums[:3])


def ensure_prerequisites(skip_checks: bool) -> None:
    if skip_checks:
        log("Skipping prerequisite checks", level="WARN")
        return

    log("Checking prerequisites...")
    for requirement in REQUIREMENTS:
        raw = capture_command(requirement["cmd"])
        version = extract_version(raw)
        current = normalize_version(version)
        minimum = normalize_version(requirement["min_version"])
        if current < minimum:
            raise RuntimeError(
                f"{requirement['name']} version {version} is below required {requirement['min_version']}"
            )
        log(f"{requirement['name']} OK (found {version})")


def root_env_template() -> str:
    return dedent(
        """\
        # Auto-generated by scripts/deploy.py
        NODE_ENV=development

        # Database
        DB_HOST=localhost
        DB_PORT=5432
        DB_USER=cms_user
        DB_PASSWORD=cms_password

        # Redis
        REDIS_HOST=localhost
        REDIS_PORT=6379

        # RabbitMQ
        RABBITMQ_HOST=localhost
        RABBITMQ_PORT=5672
        RABBITMQ_USER=cms
        RABBITMQ_PASSWORD=cms

        # JWT defaults
        JWT_SECRET=dev-jwt-secret
        JWT_EXPIRES_IN=1h
        JWT_REFRESH_EXPIRES_IN=7d

        # API Gateway
        API_GATEWAY_PORT=3000
        CORS_ORIGIN=http://localhost:5173,http://localhost:5174,http://localhost:5185

        # Service URLs
        AUTH_SERVICE_URL=http://localhost:3001
        USER_SERVICE_URL=http://localhost:3002
        DEVICE_SERVICE_URL=http://localhost:3003
        TELEMETRY_SERVICE_URL=http://localhost:3004
        ALERT_SERVICE_URL=http://localhost:3005
        LOCATION_SERVICE_URL=http://localhost:3006
        BILLING_SERVICE_URL=http://localhost:3007
        INTEGRATION_SERVICE_URL=http://localhost:3008
        DISPATCHER_SERVICE_URL=http://localhost:3009
        ANALYTICS_SERVICE_URL=http://localhost:3010
        AI_PREDICTION_SERVICE_URL=http://localhost:3011

        # Frontend apps
        GUARDIAN_APP_URL=http://localhost:5173
        DISPATCHER_APP_URL=http://localhost:5174
        ADMIN_APP_URL=http://localhost:5185
        """
    )


def api_gateway_env_template() -> str:
    return dedent(
        """\
        # Auto-generated by scripts/deploy.py
        NODE_ENV=development
        PORT=3000
        LOG_LEVEL=debug
        CORS_ORIGIN=http://localhost:5173,http://localhost:5174,http://localhost:5185

        AUTH_SERVICE_URL=http://localhost:3001
        USER_SERVICE_URL=http://localhost:3002
        DEVICE_SERVICE_URL=http://localhost:3003
        TELEMETRY_SERVICE_URL=http://localhost:3004
        ALERT_SERVICE_URL=http://localhost:3005
        LOCATION_SERVICE_URL=http://localhost:3006
        BILLING_SERVICE_URL=http://localhost:3007
        INTEGRATION_SERVICE_URL=http://localhost:3008
        DISPATCHER_SERVICE_URL=http://localhost:3009
        ANALYTICS_SERVICE_URL=http://localhost:3010
        AI_PREDICTION_SERVICE_URL=http://localhost:3011

        JWT_SECRET=dev-jwt-secret
        JWT_EXPIRES_IN=1h
        JWT_REFRESH_EXPIRES_IN=7d

        REDIS_HOST=localhost
        REDIS_PORT=6379
        RATE_LIMIT_MAX=1000
        RATE_LIMIT_WINDOW=60
        """
    )


def service_env_template(service: str) -> str:
    port = SERVICE_PORTS.get(service, 0)
    database = SERVICE_DATABASES.get(service, f"{service.replace('-service', '')}_db")
    rabbit_url = "amqp://cms:cms@localhost:5672"

    special = ""
    if service == "integration-service":
        special = dedent(
            """
            SMTP_HOST=smtp.gmail.com
            SMTP_PORT=587
            SMTP_USER=
            SMTP_PASSWORD=
            SMTP_FROM=noreply@caremonitoring.local
            TELEGRAM_BOT_TOKEN=
            """
        ).strip()

    return dedent(
        f"""\
        # Auto-generated by scripts/deploy.py for {service}
        NODE_ENV=development
        SERVICE_NAME={service}
        PORT={port}

        DB_HOST=localhost
        DB_PORT=5432
        DB_USER=cms_user
        DB_PASSWORD=cms_password
        DB_NAME={database}

        REDIS_HOST=localhost
        REDIS_PORT=6379

        RABBITMQ_URL={rabbit_url}
        EVENTS_EXCHANGE=care-monitoring.events

        JWT_SECRET=dev-jwt-secret
        JWT_EXPIRES_IN=1h

        {special}
        """
    ).strip() + "\n"


def ensure_env_files(force: bool) -> None:
    targets: dict[Path, str] = {
        PROJECT_ROOT / ".env": root_env_template(),
        PROJECT_ROOT / "api-gateway" / ".env": api_gateway_env_template(),
    }

    for service_dir in SERVICE_PORTS:
        path = PROJECT_ROOT / "microservices" / service_dir / ".env"
        targets[path] = service_env_template(service_dir)

    for path, content in targets.items():
        if path.exists() and not force:
            log(f"Env file already exists, skipping: {path}")
            continue
        path.parent.mkdir(parents=True, exist_ok=True)
        path.write_text(content.strip() + "\n", encoding="utf-8")
        log(f"Env file created: {path}")


def install_dependencies(skip_install: bool) -> None:
    if skip_install:
        log("Skipping npm install as requested", level="WARN")
        return
    log("Installing npm workspaces...")
    run_command(["npm", "install"])


def start_infrastructure(skip_infra: bool) -> None:
    if skip_infra:
        log("Skipping infrastructure startup", level="WARN")
        return
    log("Starting infrastructure via docker-compose...")
    run_command(["npm", "run", "dev:infra"])


def run_migrations(skip_migrate: bool) -> None:
    if skip_migrate:
        log("Skipping migrations", level="WARN")
        return
    log("Applying database migrations...")
    run_command(["npm", "run", "db:migrate"])


def start_services(run_services: bool) -> None:
    if not run_services:
        log("Service startup skipped (use --start-services to enable)")
        return
    log("Launching API Gateway, microservices, and guardian frontend...")
    run_command(["npm", "run", "dev:all"])


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Bootstrap and deploy the Care Monitoring System locally."
    )
    parser.add_argument(
        "--force-env",
        action="store_true",
        help="Overwrite existing .env files with default templates.",
    )
    parser.add_argument(
        "--skip-checks",
        action="store_true",
        help="Skip prerequisite validation (not recommended).",
    )
    parser.add_argument(
        "--skip-install",
        action="store_true",
        help="Skip npm install step.",
    )
    parser.add_argument(
        "--skip-infra",
        action="store_true",
        help="Do not start docker-compose infrastructure.",
    )
    parser.add_argument(
        "--skip-migrations",
        action="store_true",
        help="Do not run database migrations.",
    )
    parser.add_argument(
        "--start-services",
        action="store_true",
        help="Start backend and frontend services via npm run dev:all (blocks current terminal).",
    )
    return parser.parse_args()


def main() -> None:
    os.chdir(PROJECT_ROOT)
    args = parse_args()

    log(f"Project root: {PROJECT_ROOT}")
    log(f"Detected platform: {platform.system()} {platform.release()}")

    ensure_prerequisites(skip_checks=args.skip_checks)
    ensure_env_files(force=args.force_env)
    install_dependencies(skip_install=args.skip_install)
    start_infrastructure(skip_infra=args.skip_infra)
    run_migrations(skip_migrate=args.skip_migrations)
    start_services(run_services=args.start_services)

    log("Deployment sequence completed successfully. Happy hacking!", level="SUCCESS")
    if not args.start_services:
        log("Next steps:")
        log("  • npm run dev:gateway")
        log("  • npm run dev:services")
        log("  • npm run dev:frontend")
        log("Or run `npm run dev:all` to start everything at once.")


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        log("Interrupted by user", level="WARN")
        sys.exit(130)
    except Exception as error:  # noqa: BLE001
        log(str(error), level="ERROR")
        sys.exit(1)




