# Архитектурные решения (ADR)

Задокументированные архитектурные решения проекта Care Monitoring System.

## ADR-001: Микросервисная архитектура

**Статус**: Принято

**Контекст**: 
Необходимо выбрать архитектурный подход для системы мониторинга здоровья с высокими требованиями к масштабируемости и надежности.

**Решение**:
Использовать микросервисную архитектуру с разделением на доменные сервисы:
- Auth Service
- User Service
- Device Service
- Telemetry Service
- Alert Service
- Location Service
- Billing Service
- Integration Service
- Dispatcher Service
- Analytics Service
- AI Prediction Service
- Organization Service (новый)

**Последствия**:
- ✅ Независимое развертывание и масштабирование
- ✅ Изоляция отказов
- ✅ Разные технологии для разных сервисов
- ❌ Усложнение коммуникации между сервисами
- ❌ Необходимость управления распределенными транзакциями

## ADR-002: Event-Driven коммуникация

**Статус**: Принято

**Контекст**:
Необходимо обеспечить слабую связанность между микросервисами и поддержку асинхронной обработки.

**Решение**:
Использовать RabbitMQ как message broker для event-driven коммуникации:
- Topic exchange для маршрутизации событий
- Очереди для каждого типа событий
- Dead Letter Queue для обработки ошибок

**Последствия**:
- ✅ Слабая связанность сервисов
- ✅ Асинхронная обработка
- ✅ Масштабируемость
- ❌ Сложность отладки распределенных систем
- ❌ Необходимость обработки дубликатов

## ADR-003: Database per Service

**Статус**: Принято

**Контекст**:
Необходимо обеспечить независимость данных между микросервисами.

**Решение**:
Каждый микросервис имеет свою базу данных (schema в общем PostgreSQL кластере):
- Изоляция данных
- Независимые миграции
- Оптимизация под конкретный сервис

**Последствия**:
- ✅ Независимость данных
- ✅ Оптимизация под конкретные нужды
- ✅ Изоляция отказов
- ❌ Сложность транзакций между сервисами
- ❌ Дублирование данных (нормализованное через события)

## ADR-004: NestJS как основной фреймворк

**Статус**: Принято

**Контекст**:
Необходимо выбрать фреймворк для backend микросервисов.

**Решение**:
Использовать NestJS для всех микросервисов:
- TypeScript из коробки
- Dependency Injection
- Модульная архитектура
- Хорошая экосистема

**Последствия**:
- ✅ Единообразие кода
- ✅ Хорошая поддержка TypeScript
- ✅ Модульная архитектура
- ❌ Кривая обучения для команды
- ❌ Больше boilerplate кода

## ADR-005: Vue.js для frontend

**Статус**: Принято

**Контекст**:
Необходимо выбрать фреймворк для веб-приложений.

**Решение**:
Использовать Vue.js 3 с Composition API:
- Простота обучения
- Хорошая производительность
- Composition API для переиспользования логики
- TypeScript поддержка

**Последствия**:
- ✅ Простота разработки
- ✅ Хорошая производительность
- ✅ Активное сообщество
- ❌ Меньше готовых компонентов чем у React

## ADR-006: React Native для мобильных приложений

**Статус**: Принято

**Контекст**:
Необходимо выбрать технологию для кроссплатформенного мобильного приложения.

**Решение**:
Использовать React Native:
- Один код для iOS и Android
- Доступ к нативным API (Bluetooth, GPS)
- Большая экосистема

**Последствия**:
- ✅ Кроссплатформенность
- ✅ Доступ к нативным функциям
- ✅ Активное сообщество
- ❌ Необходимость нативных модулей для специфичных функций

## ADR-007: PostgreSQL как основная БД

**Статус**: Принято

**Контекст**:
Необходимо выбрать основную базу данных для системы.

**Решение**:
Использовать PostgreSQL:
- ACID транзакции
- JSON поддержка
- PostGIS для геоданных
- Надежность и производительность

**Последствия**:
- ✅ Надежность
- ✅ Поддержка сложных запросов
- ✅ PostGIS для геоданных
- ❌ Может быть избыточно для простых случаев

## ADR-008: ClickHouse для аналитики

**Статус**: Принято

**Контекст**:
Необходимо хранить большие объемы телеметрии для аналитики.

**Решение**:
Использовать ClickHouse для архивных данных телеметрии:
- Высокая производительность для аналитических запросов
- Сжатие данных
- Партиционирование

**Последствия**:
- ✅ Высокая производительность
- ✅ Эффективное хранение
- ❌ Дополнительная инфраструктура
- ❌ Сложность синхронизации данных

## ADR-009: AI Prediction как отдельный сервис

**Статус**: Принято

**Контекст**:
Необходимо интегрировать AI/ML функциональность в систему.

**Решение**:
Создать отдельный AI Prediction Service:
- Изоляция ML логики
- Независимое масштабирование
- Возможность использования разных ML фреймворков

**Последствия**:
- ✅ Изоляция ML логики
- ✅ Независимое масштабирование
- ✅ Гибкость в выборе ML инструментов
- ❌ Задержка на сетевые вызовы
- ❌ Необходимость управления моделями

## ADR-010: API Gateway Pattern

**Статус**: Принято

**Контекст**:
Необходимо обеспечить единую точку входа для всех клиентов.

**Решение**:
Использовать API Gateway:
- Единая точка входа
- Централизованная аутентификация
- Rate limiting
- Агрегация данных

**Последствия**:
- ✅ Единая точка входа
- ✅ Централизованная безопасность
- ✅ Упрощение клиентского кода
- ❌ Потенциальное узкое место
- ❌ Необходимость масштабирования Gateway

## ADR-011: CQRS для телеметрии

**Статус**: Принято

**Контекст**:
Необходимо оптимизировать чтение больших объемов телеметрии.

**Решение**:
Использовать CQRS для Telemetry Service:
- Разделение команд (запись) и запросов (чтение)
- Оптимизированные модели для чтения
- Агрегация данных для быстрых запросов

**Последствия**:
- ✅ Оптимизация производительности
- ✅ Масштабируемость чтения
- ❌ Усложнение архитектуры
- ❌ Необходимость синхронизации данных

## ADR-012: WebSocket для real-time обновлений

**Статус**: Принято

**Контекст**:
Необходимо обеспечить real-time обновления в frontend приложениях.

**Решение**:
Использовать WebSocket через API Gateway:
- Real-time обновления
- Эффективное использование ресурсов
- Поддержка подписок на каналы

**Последствия**:
- ✅ Real-time обновления
- ✅ Эффективность
- ❌ Управление соединениями
- ❌ Необходимость обработки переподключений

## ADR-013: Kubernetes для production

**Статус**: Принято

**Контекст**:
Необходимо выбрать платформу для оркестрации контейнеров в production.

**Решение**:
Использовать Kubernetes:
- Автоматическое масштабирование
- Self-healing
- Управление секретами
- Широкое распространение

**Последствия**:
- ✅ Автоматизация
- ✅ Масштабируемость
- ✅ Надежность
- ❌ Сложность настройки
- ❌ Необходимость экспертизы

## ADR-014: Prometheus + Grafana для мониторинга

**Статус**: Принято

**Контекст**:
Необходимо обеспечить мониторинг системы.

**Решение**:
Использовать Prometheus для сбора метрик и Grafana для визуализации:
- Стандартное решение
- Хорошая интеграция с Kubernetes
- Активное сообщество

**Последствия**:
- ✅ Стандартное решение
- ✅ Хорошая интеграция
- ✅ Гибкость
- ❌ Необходимость настройки
- ❌ Ресурсы для хранения метрик

## ADR-015: Loki для логирования

**Статус**: Принято

**Контекст**:
Необходимо централизованное логирование для всех сервисов.

**Решение**:
Использовать Loki для агрегации логов:
- Интеграция с Grafana
- Эффективное хранение
- Простой запрос логов

**Последствия**:
- ✅ Централизованное логирование
- ✅ Интеграция с Grafana
- ✅ Эффективность
- ❌ Ограничения по сравнению с ELK

## ADR-016: Multi-Tenancy для B2B

**Статус**: Принято

**Контекст**: 
Необходимо обеспечить возможность создания изолированных аккаунтов для множества организаций (диспетчерских служб) с возможностью установки коммерческих тарифов для B2B.

**Решение**:
Реализовать multi-tenancy архитектуру на основе организации (tenant):
- Каждая организация имеет полностью изолированные данные
- Все пользователи привязаны к организации через `organization_id`
- JWT токены включают `organizationId` для автоматической фильтрации
- `TenantGuard` обеспечивает изоляцию на уровне приложения
- Тарифные планы назначаются на уровне организации
- Лимиты ресурсов (подопечные, диспетчеры) на уровне организации
- Row-level filtering через `organization_id` во всех таблицах

**Последствия**:
- ✅ Полная изоляция данных между организациями
- ✅ Гибкие тарифные планы для B2B
- ✅ Масштабируемость для множества организаций
- ✅ Безопасность на всех уровнях (БД, приложение, JWT)
- ✅ Простота управления организациями
- ❌ Усложнение запросов (необходимость фильтрации по `organization_id`)
- ❌ Необходимость миграции существующих данных
- ❌ Дополнительные индексы для производительности

**Альтернативы**:
- **Database per Tenant**: Отдельная БД для каждой организации - слишком сложно для управления и масштабирования
- **Schema per Tenant**: Отдельная схема для каждой организации - сложность миграций и управления
- **Row-level Security (RLS)**: Использование RLS в PostgreSQL - выбрано как оптимальный баланс между изоляцией и производительностью

**Реализация**:
- Создан `OrganizationService` для управления организациями
- Добавлен `TenantGuard` для автоматической проверки изоляции
- Обновлены JWT токены для включения `organizationId`
- Все репозитории фильтруют данные по `organization_id`
- Тарифные планы на уровне организации с лимитами ресурсов
- Миграции для существующих данных с созданием дефолтной организации

**Метрики производительности**:
- Фильтрация по `organization_id`: < 10ms (с индексами)
- Проверка лимитов: < 5ms
- Создание организации: < 50ms

## Шаблон для новых ADR

```markdown
## ADR-XXX: [Название решения]

**Статус**: [Предложено | Принято | Отклонено | Заменено]

**Контекст**: 
[Описание проблемы или ситуации]

**Решение**:
[Описание принятого решения]

**Последствия**:
- ✅ Положительные последствия
- ❌ Отрицательные последствия

**Альтернативы**:
- [Альтернатива 1]: [Почему не выбрана]
- [Альтернатива 2]: [Почему не выбрана]
```


- ✅ Простота управления организациями
- ❌ Усложнение запросов (необходимость фильтрации по `organization_id`)
- ❌ Необходимость миграции существующих данных
- ❌ Дополнительные индексы для производительности

**Альтернативы**:
- **Database per Tenant**: Отдельная БД для каждой организации - слишком сложно для управления и масштабирования
- **Schema per Tenant**: Отдельная схема для каждой организации - сложность миграций и управления
- **Row-level Security (RLS)**: Использование RLS в PostgreSQL - выбрано как оптимальный баланс между изоляцией и производительностью

**Реализация**:
- Создан `OrganizationService` для управления организациями
- Добавлен `TenantGuard` для автоматической проверки изоляции
- Обновлены JWT токены для включения `organizationId`
- Все репозитории фильтруют данные по `organization_id`
- Тарифные планы на уровне организации с лимитами ресурсов
- Миграции для существующих данных с созданием дефолтной организации

**Метрики производительности**:
- Фильтрация по `organization_id`: < 10ms (с индексами)
- Проверка лимитов: < 5ms
- Создание организации: < 50ms

## Шаблон для новых ADR

```markdown
## ADR-XXX: [Название решения]

**Статус**: [Предложено | Принято | Отклонено | Заменено]

**Контекст**: 
[Описание проблемы или ситуации]

**Решение**:
[Описание принятого решения]

**Последствия**:
- ✅ Положительные последствия
- ❌ Отрицательные последствия

**Альтернативы**:
- [Альтернатива 1]: [Почему не выбрана]
- [Альтернатива 2]: [Почему не выбрана]
```
